[
 {
  "author_association":"MEMBER",
  "body":"I'm going to try squashing this one with GitHub.",
  "created_at":"2019-08-26T21:49:44Z",
  "id":525047027,
  "issue":3,
  "node_id":"MDEyOklzc3VlQ29tbWVudDUyNTA0NzAyNw==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-08-26T21:49:44Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"Will come back to this. `ListArray` is first.",
  "created_at":"2019-09-26T17:57:45Z",
  "id":535618154,
  "issue":10,
  "node_id":"MDEyOklzc3VlQ29tbWVudDUzNTYxODE1NA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-09-26T17:57:45Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"JSON is done (along with some plots for CHEP).",
  "created_at":"2019-11-03T21:05:00Z",
  "id":549178455,
  "issue":19,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU0OTE3ODQ1NQ==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-11-03T21:05:00Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"Good start!",
  "created_at":"2019-12-06T12:47:45Z",
  "id":562558382,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2MjU1ODM4Mg==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-06T12:47:45Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"I'd like to approve your PR on a shorter timescale than I'll be able to update the README, and the QUICKSTART.md content you've written belongs in the REAME. When the time comes to merge this PR, it would be best if you remove QUICKSTART.md.\r\n\r\nAlso, note that your next step will be CMakeLists.txt, where you'll add your test. Probably the easiest way to get started is to make it a trivial test (`main` always returns `0`) to get the machinery in place, then add substantial tests, and make sure that doing it wrong causes the test to fail.",
  "created_at":"2019-12-09T22:59:38Z",
  "id":563479214,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2MzQ3OTIxNA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-09T22:59:38Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"@glass-ships Tests are all green; you're good to go!\r\n\r\nBut try doing this:\r\n\r\n```c++\r\nmyarray.beginrecord();\r\nmyarray.field(\"x\");\r\nmyarray.boolean(true);\r\nmyarray.field(\"y\");\r\nmyarray.integer(1);\r\nmyarray.field(\"z\");\r\nmyarray.real(1.1);\r\nmyarray.endrecord();\r\n```\r\n\r\ninstead to avoid creating unions. You probably want records that have [a field for each contained type](https://en.wikipedia.org/wiki/Product_type), not a union for which every [item is chosen from a set of types](https://en.wikipedia.org/wiki/Tagged_union).",
  "created_at":"2019-12-12T18:07:49Z",
  "id":565119681,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTExOTY4MQ==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-12T18:07:49Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"CONTRIBUTOR",
  "body":"Thanks for the tips, confirmed test is now working with your fix! I'll look at your suggested code, and keep in mind to avoid union types for the time being ",
  "created_at":"2019-12-12T21:50:27Z",
  "id":565202900,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTIwMjkwMA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-12T21:50:27Z",
  "user":"MDQ6VXNlcjI2OTc1NTMw"
 },
 {
  "author_association":"CONTRIBUTOR",
  "body":"I'm a little curious now that I'm switching the code around - what is the main difference between a \"record\" and a \"list\" in awkward's context? I think I understand the \"field\" object, it's a sort of organizational scheme paired with a value of a certain type, correct? ",
  "created_at":"2019-12-13T02:11:47Z",
  "id":565270403,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTI3MDQwMw==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T02:11:47Z",
  "user":"MDQ6VXNlcjI2OTc1NTMw"
 },
 {
  "author_association":"MEMBER",
  "body":"Think of this equivalence:\r\n\r\n- Python list of all the same type of object \u2194 Awkward list\r\n- Python list of arbitrary types \u2194 Awkward list of union (not implemented as an array yet)\r\n- Python dict \u2194 Awkward record\r\n- one key in that dict \u2194 Awkward field\r\n- Python tuple of a fixed length \u2194 Awkward tuple\r\n- one slot in that tuple \u2194 Awkward index\r\n- quantity that could be `None` \u2194 Awkward option (not implemented as an array yet)\r\n\r\nAwkward arrays are a static type system (as are NumPy arrays, though NumPy is mostly limited to numeric types). In a static type system, a list has to contain objects of all the same type (\"homogeneous\") unless there's some structure that spells out what types are allowed: an Awkward union.\r\n\r\nPython dicts are not statically typed; different dicts can have different keys and the values associated with those keys can be different types. Awkward records are more like C structs (or C++ classes). In an array with record type, all the records have to have the same keys and the values associated with one key have to all have the same type.\r\n\r\nIn Python, the distinction between lists and tuples is slight: tuples are immutable. In a static type system, there's more difference: lists in an array can have different lengths, but the items in those lists must have the same type; tuples in an array must have the same length, but the items in each slot can have different types. However, the items in a single slot `i` must have the same type for all tuples in the array.\r\n\r\nIn this kind of system, the difference between a tuple and a record is slight: both have a fixed number of fields that can have different types in the tuple/record (though each field must have the same type across the array), but the slots in a tuple are identified by integers while the slots in a record are identified by constant strings.",
  "created_at":"2019-12-13T03:07:37Z",
  "id":565281496,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTI4MTQ5Ng==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T03:07:37Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"CONTRIBUTOR",
  "body":"I thank you for the thorough explanation, that makes a lot of sense!\r\n\r\nI've run into another problem, however, as it appears that:  \r\n `'class awkward::FillableArray' has no member named 'field'`.\r\n\r\n Which actually seems to check out, I couldn't find a member description in the FillableArray header or cpp files. It seems to work in the python version though, which makes me wonder, are the python and c++ functions defined separately? (it was my initial assumption the python was interfacing with awkward via c++ wrappers) ",
  "created_at":"2019-12-13T03:48:08Z",
  "id":565288998,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTI4ODk5OA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T03:48:08Z",
  "user":"MDQ6VXNlcjI2OTc1NTMw"
 },
 {
  "author_association":"MEMBER",
  "body":"Oh\u2014use `field_check`. That is what `field` is in Python.\r\n\r\nThe alternative, `field_fast`, doesn't check the string value, only its pointer, which makes it applicable only to strings that are known to have unchanging pointers (like literal strings, which is a common case). I also use `field_fast` in Numba, where I can create fixed pointers if the strings are known at compile-time.\r\n\r\nIf you're not sure, use `field_check`.",
  "created_at":"2019-12-13T11:22:57Z",
  "id":565406397,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTQwNjM5Nw==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T11:22:57Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"You can remove your QUICKSTART now; the information is on the new front-page README.\r\n\r\nI'll help you with those conflicts soon.",
  "created_at":"2019-12-13T20:04:36Z",
  "id":565589318,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTU4OTMxOA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T20:04:36Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"I see you're online right now. Do you want me to merge with master, resolving all the conflicts (until the next PR...)?",
  "created_at":"2019-12-13T20:14:19Z",
  "id":565592627,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTU5MjYyNw==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T20:14:19Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"@glass-ships The previous commit merges with master (takes all changes from master except your test). If it's not what you want, it can be reverted with git.\r\n\r\nThe next one fixes the test file so that it compiles (part of my sanity checks).",
  "created_at":"2019-12-13T20:24:31Z",
  "id":565596029,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTU5NjAyOQ==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T20:31:19Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"CONTRIBUTOR",
  "body":"Sure! I think we're getting pretty close to wrapping this test up, too; once the array gets filled appropriately, I think we'll be happy with a simple print-out to json and confirm it matches what we expect it to. ",
  "created_at":"2019-12-13T20:25:30Z",
  "id":565596334,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTU5NjMzNA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T20:25:30Z",
  "user":"MDQ6VXNlcjI2OTc1NTMw"
 },
 {
  "author_association":"MEMBER",
  "body":"I'm done merging now: `git pull`, do the \"make clean\" (that `rm` command, now on the front README), recompile, and you're ready to go!",
  "created_at":"2019-12-13T20:32:16Z",
  "id":565598484,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTU5ODQ4NA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T20:32:16Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"Okay, now I'm done. I wanted to make sure that the only differences between this branch and master is in your test file. Now it is.",
  "created_at":"2019-12-13T20:35:09Z",
  "id":565599418,
  "issue":30,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NTU5OTQxOA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-13T20:35:09Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"COLLABORATOR",
  "body":"yes, I agree.",
  "created_at":"2019-12-18T06:52:53Z",
  "id":566893431,
  "issue":34,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2Njg5MzQzMQ==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-18T06:52:53Z",
  "user":"MDQ6VXNlcjEzOTA2ODI="
 },
 {
  "author_association":"COLLABORATOR",
  "body":"ok, I'm closing this PR for now.",
  "created_at":"2019-12-18T12:42:12Z",
  "id":567015783,
  "issue":35,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NzAxNTc4Mw==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-18T12:42:12Z",
  "user":"MDQ6VXNlcjEzOTA2ODI="
 },
 {
  "author_association":"COLLABORATOR",
  "body":"reopen to add clang-tidy fixes with a <b>readability-redundant-smartptr-get</b> check:\r\nhttps://clang.llvm.org/extra/clang-tidy/checks/readability-redundant-smartptr-get.html",
  "created_at":"2019-12-18T13:28:23Z",
  "id":567030990,
  "issue":35,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NzAzMDk5MA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-18T13:28:23Z",
  "user":"MDQ6VXNlcjEzOTA2ODI="
 },
 {
  "author_association":"COLLABORATOR",
  "body":"automated fixes with <b>readability-avoid-const-params-in-decls</b> check remove const in places where it could be a reference:\r\n```\r\ndiff --git a/include/awkward/Index.h b/include/awkward/Index.h\r\nindex 40f7a59..2ad904b 100644\r\n--- a/include/awkward/Index.h\r\n+++ b/include/awkward/Index.h\r\n@@ -32,7 +32,7 @@ namespace awkward {\r\n \r\n     const std::string classname() const;\r\n     const std::string tostring() const;\r\n-    const std::string tostring_part(const std::string indent, const std::string pre, const std::string post) const;\r\n+    const std::string tostring_part(std::string indent, std::string pre, std::string post) const;\r\n     T getitem_at(int64_t at) const;\r\n     T getitem_at_nowrap(int64_t at) const;\r\n     void setitem_at_nowrap(int64_t at, T value) const;\r\n```\r\nhttps://clang.llvm.org/extra/clang-tidy/checks/readability-avoid-const-params-in-decls.html",
  "created_at":"2019-12-18T13:41:19Z",
  "id":567035766,
  "issue":35,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NzAzNTc2Ng==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-18T13:41:19Z",
  "user":"MDQ6VXNlcjEzOTA2ODI="
 },
 {
  "author_association":"MEMBER",
  "body":"In the above example, I'm going to want to make sure that it says\r\n\r\n```python\r\nconst std::string tostring_part(const std::string& indent, const std::string& pre, const std::string& post) const;\r\n```\r\n\r\nI just haven't been diligent about making sure that all such cases are explicit.\r\n\r\nMost of the function arguments are either simple numbers, which should be passed by value, or unmodified structures, which should be pass-by-const-reference. It's very rare that I'll want to copy a structure into the function (as the mistaken case above) or pass a non-const reference for remote modification (though there are a few cases, but I think they're numbers).",
  "created_at":"2019-12-18T13:47:17Z",
  "id":567038108,
  "issue":35,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NzAzODEwOA==",
  "performed_via_github_app":null,
  "reactions":{
   "+1":1,
   "total_count":1
  },
  "updated_at":"2019-12-18T13:47:17Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"MEMBER",
  "body":"My last four commits to PR #33 applied the corrections that clang-tidy wants to make, but manually with much testing to make sure that it agrees with my intentions. If you run clang-tidy over that, we should see what residual changes it wants to make with much less noise.\r\n\r\nThis is not including the removal of `.get()` from shared pointers. I want to do that, as a reminder of the distinction between a shared pointer and a raw pointer. (There are a few, very rare cases where raw pointers are necessary, particularly for interacting with the bottom layer in the architecture through an \"extern C\" interface.)",
  "created_at":"2019-12-18T17:52:07Z",
  "id":567140461,
  "issue":35,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NzE0MDQ2MQ==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-18T17:52:07Z",
  "user":"MDQ6VXNlcjE4NTI0NDc="
 },
 {
  "author_association":"COLLABORATOR",
  "body":"> My last four commits to PR #33 applied the corrections that clang-tidy wants to make, but manually with much testing to make sure that it agrees with my intentions. If you run clang-tidy over that, we should see what residual changes it wants to make with much less noise.\r\n> \r\n> This is not including the removal of `.get()` from shared pointers. I want to do that, as a reminder of the distinction between a shared pointer and a raw pointer. (There are a few, very rare cases where raw pointers are necessary, particularly for interacting with the bottom layer in the architecture through an \"extern C\" interface.)\r\n\r\nThanks, @jpivarski ! I'll do it tomorrow. I've been checking other clang-tidy checks. The good news is that most of them come clean. There are two we may want to look closely: <i>modernize-pass-by-value</i> (https://clang.llvm.org/extra/clang-tidy/checks/modernize-pass-by-value.html) and <i>readability-avoid-const-params-in-decls</i>",
  "created_at":"2019-12-18T18:17:43Z",
  "id":567149660,
  "issue":35,
  "node_id":"MDEyOklzc3VlQ29tbWVudDU2NzE0OTY2MA==",
  "performed_via_github_app":null,
  "reactions":{},
  "updated_at":"2019-12-18T18:17:43Z",
  "user":"MDQ6VXNlcjEzOTA2ODI="
 }
]